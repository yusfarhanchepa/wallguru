"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

module.exports =
/*#__PURE__*/
function () {
  function Interceptor(API) {
    var _this = this;

    var interceptableMethods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    _classCallCheck(this, Interceptor);

    this.interceptors = [];
    if (!API) throw new Error('API should be passed to the Interceptor');
    if (interceptableMethods.length === 0) throw new Error('no methods were added to interceptableMethods');
    interceptableMethods.forEach(function (methodName) {
      var methodFn = API[methodName];

      API[methodName] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _this.interceptedMethod.apply(_this, [methodFn].concat(args));
      };
    });
  }

  _createClass(Interceptor, [{
    key: "interceptedMethod",
    value: function interceptedMethod(methodFn) {
      var interceptors = this.interceptors;
      var reversedInterceptors = interceptors.slice().reverse();

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      var promise = Promise.resolve(args); // Register request interceptors

      interceptors.forEach(function (_ref) {
        var request = _ref.request,
            requestError = _ref.requestError;
        if (typeof request === 'function') promise = promise.then(function (args) {
          return request.apply(void 0, _toConsumableArray([].concat(args)));
        });
        if (typeof requestError === 'function') promise = promise.catch(requestError);
      }); // Register methodFn call

      if (typeof methodFn === 'function') promise = promise.then(function (args) {
        return methodFn.apply(void 0, _toConsumableArray([].concat(args)));
      }); // Register response interceptors

      reversedInterceptors.forEach(function (_ref2) {
        var response = _ref2.response,
            responseError = _ref2.responseError;
        if (typeof response === 'function') promise = promise.then(response);
        if (typeof responseError === 'function') promise = promise.catch(responseError);
      });
      return promise;
    }
  }, {
    key: "register",
    value: function register(interceptor) {
      var _this2 = this;

      this.interceptors.push(interceptor);
      return function () {
        return _this2.unregister(interceptor);
      };
    }
  }, {
    key: "unregister",
    value: function unregister(interceptor) {
      var index = this.interceptors.indexOf(interceptor);
      if (index >= 0) this.interceptors.splice(index, 1);
    }
  }, {
    key: "clear",
    value: function clear() {
      this.interceptors = [];
    }
  }]);

  return Interceptor;
}();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbnRlcmNlcHRvci5qcyJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiQVBJIiwiaW50ZXJjZXB0YWJsZU1ldGhvZHMiLCJpbnRlcmNlcHRvcnMiLCJFcnJvciIsImxlbmd0aCIsImZvckVhY2giLCJtZXRob2RGbiIsIm1ldGhvZE5hbWUiLCJhcmdzIiwiaW50ZXJjZXB0ZWRNZXRob2QiLCJyZXZlcnNlZEludGVyY2VwdG9ycyIsInNsaWNlIiwicmV2ZXJzZSIsInByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlcXVlc3QiLCJyZXF1ZXN0RXJyb3IiLCJ0aGVuIiwiY29uY2F0IiwiY2F0Y2giLCJyZXNwb25zZSIsInJlc3BvbnNlRXJyb3IiLCJpbnRlcmNlcHRvciIsInB1c2giLCJ1bnJlZ2lzdGVyIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUFBLE9BQU9DLE9BQVA7QUFBQTtBQUFBO0FBQ0UsdUJBQVlDLEdBQVosRUFBNEM7QUFBQTs7QUFBQSxRQUEzQkMsb0JBQTJCLHVFQUFKLEVBQUk7O0FBQUE7O0FBQzFDLFNBQUtDLFlBQUwsR0FBb0IsRUFBcEI7QUFFQSxRQUFJLENBQUNGLEdBQUwsRUFBVSxNQUFNLElBQUlHLEtBQUosQ0FBVSx5Q0FBVixDQUFOO0FBRVYsUUFBSUYscUJBQXFCRyxNQUFyQixLQUFnQyxDQUFwQyxFQUNFLE1BQU0sSUFBSUQsS0FBSixDQUFVLCtDQUFWLENBQU47QUFFRkYseUJBQXFCSSxPQUFyQixDQUE2QixzQkFBYztBQUN6QyxVQUFNQyxXQUFXTixJQUFJTyxVQUFKLENBQWpCOztBQUNBUCxVQUFJTyxVQUFKLElBQWtCO0FBQUEsMENBQUlDLElBQUo7QUFBSUEsY0FBSjtBQUFBOztBQUFBLGVBQWEsTUFBS0MsaUJBQUwsZUFBdUJILFFBQXZCLFNBQW9DRSxJQUFwQyxFQUFiO0FBQUEsT0FBbEI7QUFDRCxLQUhEO0FBSUQ7O0FBYkg7QUFBQTtBQUFBLHNDQWVvQkYsUUFmcEIsRUFldUM7QUFBQSxVQUMzQkosWUFEMkIsR0FDVixJQURVLENBQzNCQSxZQUQyQjtBQUVuQyxVQUFNUSx1QkFBdUJSLGFBQWFTLEtBQWIsR0FBcUJDLE9BQXJCLEVBQTdCOztBQUZtQyx5Q0FBTkosSUFBTTtBQUFOQSxZQUFNO0FBQUE7O0FBSW5DLFVBQUlLLFVBQVVDLFFBQVFDLE9BQVIsQ0FBZ0JQLElBQWhCLENBQWQsQ0FKbUMsQ0FNbkM7O0FBQ0FOLG1CQUFhRyxPQUFiLENBQXFCLGdCQUErQjtBQUFBLFlBQTVCVyxPQUE0QixRQUE1QkEsT0FBNEI7QUFBQSxZQUFuQkMsWUFBbUIsUUFBbkJBLFlBQW1CO0FBQ2xELFlBQUksT0FBT0QsT0FBUCxLQUFtQixVQUF2QixFQUNFSCxVQUFVQSxRQUFRSyxJQUFSLENBQWE7QUFBQSxpQkFBUUYseUNBQVcsR0FBR0csTUFBSCxDQUFVWCxJQUFWLENBQVgsRUFBUjtBQUFBLFNBQWIsQ0FBVjtBQUNGLFlBQUksT0FBT1MsWUFBUCxLQUF3QixVQUE1QixFQUNFSixVQUFVQSxRQUFRTyxLQUFSLENBQWNILFlBQWQsQ0FBVjtBQUNILE9BTEQsRUFQbUMsQ0FjbkM7O0FBQ0EsVUFBSSxPQUFPWCxRQUFQLEtBQW9CLFVBQXhCLEVBQ0VPLFVBQVVBLFFBQVFLLElBQVIsQ0FBYTtBQUFBLGVBQVFaLDBDQUFZLEdBQUdhLE1BQUgsQ0FBVVgsSUFBVixDQUFaLEVBQVI7QUFBQSxPQUFiLENBQVYsQ0FoQmlDLENBa0JuQzs7QUFDQUUsMkJBQXFCTCxPQUFyQixDQUE2QixpQkFBaUM7QUFBQSxZQUE5QmdCLFFBQThCLFNBQTlCQSxRQUE4QjtBQUFBLFlBQXBCQyxhQUFvQixTQUFwQkEsYUFBb0I7QUFDNUQsWUFBSSxPQUFPRCxRQUFQLEtBQW9CLFVBQXhCLEVBQW9DUixVQUFVQSxRQUFRSyxJQUFSLENBQWFHLFFBQWIsQ0FBVjtBQUNwQyxZQUFJLE9BQU9DLGFBQVAsS0FBeUIsVUFBN0IsRUFDRVQsVUFBVUEsUUFBUU8sS0FBUixDQUFjRSxhQUFkLENBQVY7QUFDSCxPQUpEO0FBTUEsYUFBT1QsT0FBUDtBQUNEO0FBekNIO0FBQUE7QUFBQSw2QkEyQ1dVLFdBM0NYLEVBMkN3QjtBQUFBOztBQUNwQixXQUFLckIsWUFBTCxDQUFrQnNCLElBQWxCLENBQXVCRCxXQUF2QjtBQUNBLGFBQU87QUFBQSxlQUFNLE9BQUtFLFVBQUwsQ0FBZ0JGLFdBQWhCLENBQU47QUFBQSxPQUFQO0FBQ0Q7QUE5Q0g7QUFBQTtBQUFBLCtCQWdEYUEsV0FoRGIsRUFnRDBCO0FBQ3RCLFVBQU1HLFFBQVEsS0FBS3hCLFlBQUwsQ0FBa0J5QixPQUFsQixDQUEwQkosV0FBMUIsQ0FBZDtBQUNBLFVBQUlHLFNBQVMsQ0FBYixFQUFnQixLQUFLeEIsWUFBTCxDQUFrQjBCLE1BQWxCLENBQXlCRixLQUF6QixFQUFnQyxDQUFoQztBQUNqQjtBQW5ESDtBQUFBO0FBQUEsNEJBcURVO0FBQ04sV0FBS3hCLFlBQUwsR0FBb0IsRUFBcEI7QUFDRDtBQXZESDs7QUFBQTtBQUFBIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBJbnRlcmNlcHRvciB7XG4gIGNvbnN0cnVjdG9yKEFQSSwgaW50ZXJjZXB0YWJsZU1ldGhvZHMgPSBbXSkge1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzID0gW107XG5cbiAgICBpZiAoIUFQSSkgdGhyb3cgbmV3IEVycm9yKCdBUEkgc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgSW50ZXJjZXB0b3InKTtcblxuICAgIGlmIChpbnRlcmNlcHRhYmxlTWV0aG9kcy5sZW5ndGggPT09IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIG1ldGhvZHMgd2VyZSBhZGRlZCB0byBpbnRlcmNlcHRhYmxlTWV0aG9kcycpO1xuXG4gICAgaW50ZXJjZXB0YWJsZU1ldGhvZHMuZm9yRWFjaChtZXRob2ROYW1lID0+IHtcbiAgICAgIGNvbnN0IG1ldGhvZEZuID0gQVBJW21ldGhvZE5hbWVdO1xuICAgICAgQVBJW21ldGhvZE5hbWVdID0gKC4uLmFyZ3MpID0+IHRoaXMuaW50ZXJjZXB0ZWRNZXRob2QobWV0aG9kRm4sIC4uLmFyZ3MpO1xuICAgIH0pO1xuICB9XG5cbiAgaW50ZXJjZXB0ZWRNZXRob2QobWV0aG9kRm4sIC4uLmFyZ3MpIHtcbiAgICBjb25zdCB7IGludGVyY2VwdG9ycyB9ID0gdGhpcztcbiAgICBjb25zdCByZXZlcnNlZEludGVyY2VwdG9ycyA9IGludGVyY2VwdG9ycy5zbGljZSgpLnJldmVyc2UoKTtcblxuICAgIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGFyZ3MpO1xuXG4gICAgLy8gUmVnaXN0ZXIgcmVxdWVzdCBpbnRlcmNlcHRvcnNcbiAgICBpbnRlcmNlcHRvcnMuZm9yRWFjaCgoeyByZXF1ZXN0LCByZXF1ZXN0RXJyb3IgfSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGFyZ3MgPT4gcmVxdWVzdCguLi5bXS5jb25jYXQoYXJncykpKTtcbiAgICAgIGlmICh0eXBlb2YgcmVxdWVzdEVycm9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS5jYXRjaChyZXF1ZXN0RXJyb3IpO1xuICAgIH0pO1xuXG4gICAgLy8gUmVnaXN0ZXIgbWV0aG9kRm4gY2FsbFxuICAgIGlmICh0eXBlb2YgbWV0aG9kRm4gPT09ICdmdW5jdGlvbicpXG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGFyZ3MgPT4gbWV0aG9kRm4oLi4uW10uY29uY2F0KGFyZ3MpKSk7XG5cbiAgICAvLyBSZWdpc3RlciByZXNwb25zZSBpbnRlcmNlcHRvcnNcbiAgICByZXZlcnNlZEludGVyY2VwdG9ycy5mb3JFYWNoKCh7IHJlc3BvbnNlLCByZXNwb25zZUVycm9yIH0pID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UgPT09ICdmdW5jdGlvbicpIHByb21pc2UgPSBwcm9taXNlLnRoZW4ocmVzcG9uc2UpO1xuICAgICAgaWYgKHR5cGVvZiByZXNwb25zZUVycm9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS5jYXRjaChyZXNwb25zZUVycm9yKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgcmVnaXN0ZXIoaW50ZXJjZXB0b3IpIHtcbiAgICB0aGlzLmludGVyY2VwdG9ycy5wdXNoKGludGVyY2VwdG9yKTtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy51bnJlZ2lzdGVyKGludGVyY2VwdG9yKTtcbiAgfVxuXG4gIHVucmVnaXN0ZXIoaW50ZXJjZXB0b3IpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuaW50ZXJjZXB0b3JzLmluZGV4T2YoaW50ZXJjZXB0b3IpO1xuICAgIGlmIChpbmRleCA+PSAwKSB0aGlzLmludGVyY2VwdG9ycy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5pbnRlcmNlcHRvcnMgPSBbXTtcbiAgfVxufTtcbiJdfQ==