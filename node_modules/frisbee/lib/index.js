"use strict";

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step("next", value); } function _throw(err) { step("throw", err); } _next(); }); }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var caseless = require('caseless');

var qs = require('qs');

var fetchPonyfill = require('fetch-ponyfill');

var urlJoin = require('url-join');

var Interceptor = require('./interceptor');

var _fetchPonyfill = fetchPonyfill({
  Promise: Promise
}),
    fetch = _fetchPonyfill.fetch;

var methods = ['get', 'head', 'post', 'put', 'del', 'options', 'patch'];
var respProperties = {
  readOnly: ['headers', 'ok', 'redirected', 'status', 'statusText', 'type', 'url', 'bodyUsed'],
  writable: ['useFinalURL'],
  callable: ['clone', 'error', 'redirect', 'arrayBuffer', 'blob', 'formData', 'json', 'text']
};

function createFrisbeeResponse(origResp) {
  var resp = {
    originalResponse: origResp
  };
  respProperties.readOnly.forEach(function (prop) {
    return Object.defineProperty(resp, prop, {
      value: origResp[prop]
    });
  });
  respProperties.writable.forEach(function (prop) {
    return Object.defineProperty(resp, prop, {
      get: function get() {
        return origResp[prop];
      },
      set: function set(value) {
        origResp[prop] = value;
      }
    });
  });
  var callable = null;
  respProperties.callable.forEach(function (prop) {
    Object.defineProperty(resp, prop, {
      value: (callable = origResp[prop], typeof callable === 'function' && callable.bind(origResp))
    });
  });
  var headersObj = {};
  origResp.headers.forEach(function (pair) {
    headersObj[pair[0]] = pair[1]; // eslint-disable-line prefer-destructuring
  });
  Object.defineProperty(resp, 'headersObj', {
    value: headersObj
  });
  return resp;
}

var Frisbee =
/*#__PURE__*/
function () {
  function Frisbee() {
    var _this = this;

    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Frisbee);

    this.opts = opts;
    Object.defineProperty(this, 'parseErr', {
      enumerable: false,
      value: opts.parseErr || new Error("Invalid JSON received".concat(opts.baseURI ? " from ".concat(opts.baseURI) : ''))
    });
    this.headers = _objectSpread({}, opts.headers);
    this.arrayFormat = opts.arrayFormat || 'indices';
    this.raw = opts.raw === true;
    if (opts.auth) this.auth(opts.auth);
    methods.forEach(function (method) {
      _this[method] = _this._setup(method);
    }); // interceptor should be initialized after methods setup

    this.interceptor = new Interceptor(this, methods);
  }

  _createClass(Frisbee, [{
    key: "_setup",
    value: function _setup(method) {
      var _this2 = this;

      return function () {
        var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        // path must be string
        if (typeof path !== 'string') throw new TypeError('`path` must be a string'); // otherwise check if its an object

        if (_typeof(options) !== 'object' || Array.isArray(options)) throw new TypeError('`options` must be an object');

        var raw = options.raw,
            noRaw = _objectWithoutProperties(options, ["raw"]);

        var opts = _objectSpread({}, noRaw, {
          headers: _objectSpread({}, _this2.headers, options.headers),
          method: method === 'del' ? 'DELETE' : method.toUpperCase()
        }); // remove any nil or blank headers
        // (e.g. to automatically set Content-Type with `FormData` boundary)


        Object.keys(opts.headers).forEach(function (key) {
          if (typeof opts.headers[key] === 'undefined' || opts.headers[key] === null || opts.headers[key] === '') delete opts.headers[key];
        });
        var c = caseless(opts.headers); // in order to support Android POST requests
        // we must allow an empty body to be sent
        // https://github.com/facebook/react-native/issues/4890

        if (typeof opts.body === 'undefined' && opts.method === 'POST') {
          opts.body = '';
        } else if (_typeof(opts.body) === 'object' || Array.isArray(opts.body)) {
          if (opts.method === 'GET' || opts.method === 'DELETE') {
            var arrayFormat = _this2.arrayFormat;
            path += "?".concat(qs.stringify(opts.body, {
              arrayFormat: arrayFormat
            }));
            delete opts.body;
          } else if (c.get('Content-Type') && c.get('Content-Type').split(';')[0] === 'application/json') {
            try {
              opts.body = JSON.stringify(opts.body);
            } catch (err) {
              throw err;
            }
          }
        }

        return new Promise(
        /*#__PURE__*/
        function () {
          var _ref = _asyncToGenerator(
          /*#__PURE__*/
          _regenerator.default.mark(function _callee(resolve, reject) {
            var fullUri, originalRes, res, contentType;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.prev = 0;
                    fullUri = _this2.opts.baseURI ? urlJoin(_this2.opts.baseURI, path) : path;
                    _context.next = 4;
                    return fetch(fullUri, opts);

                  case 4:
                    originalRes = _context.sent;
                    res = createFrisbeeResponse(originalRes);
                    contentType = res.headers.get('Content-Type');

                    if (res.ok) {
                      _context.next = 29;
                      break;
                    }

                    res.err = new Error(res.statusText); // check if the response was JSON, and if so, better the error

                    if (!(contentType && contentType.includes('application/json'))) {
                      _context.next = 27;
                      break;
                    }

                    _context.prev = 10;

                    if (!(typeof res.json === 'function')) {
                      _context.next = 17;
                      break;
                    }

                    _context.next = 14;
                    return res.json();

                  case 14:
                    res.body = _context.sent;
                    _context.next = 21;
                    break;

                  case 17:
                    _context.next = 19;
                    return res.text();

                  case 19:
                    res.body = _context.sent;
                    res.body = JSON.parse(res.body);

                  case 21:
                    // attempt to use better and human-friendly error messages
                    if (_typeof(res.body) === 'object' && typeof res.body.message === 'string') {
                      res.err = new Error(res.body.message);
                    } else if (!Array.isArray(res.body) && // attempt to utilize Stripe-inspired error messages
                    _typeof(res.body.error) === 'object') {
                      if (res.body.error.message) res.err = new Error(res.body.error.message);
                      if (res.body.error.stack) res.err.stack = res.body.error.stack;
                      if (res.body.error.code) res.err.code = res.body.error.code;
                      if (res.body.error.param) res.err.param = res.body.error.param;
                    }

                    _context.next = 27;
                    break;

                  case 24:
                    _context.prev = 24;
                    _context.t0 = _context["catch"](10);
                    res.err = _this2.parseErr;

                  case 27:
                    resolve(res);
                    return _context.abrupt("return");

                  case 29:
                    if (!(raw === true || _this2.raw && raw !== false)) {
                      _context.next = 31;
                      break;
                    }

                    return _context.abrupt("return", resolve(res.originalResponse));

                  case 31:
                    if (!(contentType && contentType.includes('application/json'))) {
                      _context.next = 53;
                      break;
                    }

                    _context.prev = 32;

                    if (!(typeof res.json === 'function')) {
                      _context.next = 39;
                      break;
                    }

                    _context.next = 36;
                    return res.json();

                  case 36:
                    res.body = _context.sent;
                    _context.next = 43;
                    break;

                  case 39:
                    _context.next = 41;
                    return res.text();

                  case 41:
                    res.body = _context.sent;
                    res.body = JSON.parse(res.body);

                  case 43:
                    _context.next = 51;
                    break;

                  case 45:
                    _context.prev = 45;
                    _context.t1 = _context["catch"](32);

                    if (!(contentType === 'application/json')) {
                      _context.next = 51;
                      break;
                    }

                    res.err = _this2.parseErr;
                    resolve(res);
                    return _context.abrupt("return");

                  case 51:
                    _context.next = 56;
                    break;

                  case 53:
                    _context.next = 55;
                    return res.text();

                  case 55:
                    res.body = _context.sent;

                  case 56:
                    resolve(res);
                    _context.next = 62;
                    break;

                  case 59:
                    _context.prev = 59;
                    _context.t2 = _context["catch"](0);
                    reject(_context.t2);

                  case 62:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[0, 59], [10, 24], [32, 45]]);
          }));

          return function (_x, _x2) {
            return _ref.apply(this, arguments);
          };
        }());
      };
    }
  }, {
    key: "auth",
    value: function auth(creds) {
      if (typeof creds === 'string') {
        var index = creds.indexOf(':');
        if (index !== -1) creds = [creds.substr(0, index), creds.substr(index + 1)];
      }

      if (!Array.isArray(creds)) {
        // eslint-disable-next-line prefer-rest-params
        creds = [].slice.call(arguments);
      }

      switch (creds.length) {
        case 0:
          creds = ['', ''];
          break;

        case 1:
          creds.push('');
          break;

        case 2:
          break;

        default:
          throw new Error('auth option can only have two keys `[user, pass]`');
      }

      if (typeof creds[0] !== 'string') throw new TypeError('auth option `user` must be a string');
      if (typeof creds[1] !== 'string') throw new TypeError('auth option `pass` must be a string');

      if (!creds[0] && !creds[1]) {
        delete this.headers.Authorization;
      } else {
        this.headers.Authorization = "Basic ".concat(Buffer.from(creds.join(':')).toString('base64'));
      }

      return this;
    }
  }, {
    key: "jwt",
    value: function jwt(token) {
      if (token === null) delete this.headers.Authorization;else if (typeof token === 'string') this.headers.Authorization = "Bearer ".concat(token);else throw new TypeError('jwt token must be a string');
      return this;
    }
  }]);

  return Frisbee;
}();

module.exports = Frisbee;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJjYXNlbGVzcyIsInJlcXVpcmUiLCJxcyIsImZldGNoUG9ueWZpbGwiLCJ1cmxKb2luIiwiSW50ZXJjZXB0b3IiLCJQcm9taXNlIiwiZmV0Y2giLCJtZXRob2RzIiwicmVzcFByb3BlcnRpZXMiLCJyZWFkT25seSIsIndyaXRhYmxlIiwiY2FsbGFibGUiLCJjcmVhdGVGcmlzYmVlUmVzcG9uc2UiLCJvcmlnUmVzcCIsInJlc3AiLCJvcmlnaW5hbFJlc3BvbnNlIiwiZm9yRWFjaCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwicHJvcCIsInZhbHVlIiwiZ2V0Iiwic2V0IiwiYmluZCIsImhlYWRlcnNPYmoiLCJoZWFkZXJzIiwicGFpciIsIkZyaXNiZWUiLCJvcHRzIiwiZW51bWVyYWJsZSIsInBhcnNlRXJyIiwiRXJyb3IiLCJiYXNlVVJJIiwiYXJyYXlGb3JtYXQiLCJyYXciLCJhdXRoIiwibWV0aG9kIiwiX3NldHVwIiwiaW50ZXJjZXB0b3IiLCJwYXRoIiwib3B0aW9ucyIsIlR5cGVFcnJvciIsIkFycmF5IiwiaXNBcnJheSIsIm5vUmF3IiwidG9VcHBlckNhc2UiLCJrZXlzIiwia2V5IiwiYyIsImJvZHkiLCJzdHJpbmdpZnkiLCJzcGxpdCIsIkpTT04iLCJlcnIiLCJyZXNvbHZlIiwicmVqZWN0IiwiZnVsbFVyaSIsIm9yaWdpbmFsUmVzIiwicmVzIiwiY29udGVudFR5cGUiLCJvayIsInN0YXR1c1RleHQiLCJpbmNsdWRlcyIsImpzb24iLCJ0ZXh0IiwicGFyc2UiLCJtZXNzYWdlIiwiZXJyb3IiLCJzdGFjayIsImNvZGUiLCJwYXJhbSIsImNyZWRzIiwiaW5kZXgiLCJpbmRleE9mIiwic3Vic3RyIiwic2xpY2UiLCJjYWxsIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwicHVzaCIsIkF1dGhvcml6YXRpb24iLCJCdWZmZXIiLCJmcm9tIiwiam9pbiIsInRvU3RyaW5nIiwidG9rZW4iLCJtb2R1bGUi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QUFkLEVBQW9CLE9BQU8sS0FBSzVELE9BQUwsQ0FBYXVELGFBQXBCLENBQXBCLEtBQ0ssSUFBSSxPQUFPSyxLQUFQLEtBQWlCLFFBQXJCLEVBQ0gsS0FBSzVELE9BQUwsQ0FBYXVELGFBQWIsb0JBQXVDSyxLQUF2QyxFQURHLEtBRUEsTUFBTSxJQUFJNUMsU0FBSixDQUFjLDRCQUFkLENBQU47QUFFTCxhQUFPLElBQVA7QUFDRDs7Ozs7O0FBR0g2QyxPQUFPQyxPQUFQLEdBQWlCNUQsT0FBakIiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjYXNlbGVzcyA9IHJlcXVpcmUoJ2Nhc2VsZXNzJyk7XG5jb25zdCBxcyA9IHJlcXVpcmUoJ3FzJyk7XG5jb25zdCBmZXRjaFBvbnlmaWxsID0gcmVxdWlyZSgnZmV0Y2gtcG9ueWZpbGwnKTtcbmNvbnN0IHVybEpvaW4gPSByZXF1aXJlKCd1cmwtam9pbicpO1xuXG5jb25zdCBJbnRlcmNlcHRvciA9IHJlcXVpcmUoJy4vaW50ZXJjZXB0b3InKTtcblxuY29uc3QgeyBmZXRjaCB9ID0gZmV0Y2hQb255ZmlsbCh7IFByb21pc2UgfSk7XG5cbmNvbnN0IG1ldGhvZHMgPSBbJ2dldCcsICdoZWFkJywgJ3Bvc3QnLCAncHV0JywgJ2RlbCcsICdvcHRpb25zJywgJ3BhdGNoJ107XG5cbmNvbnN0IHJlc3BQcm9wZXJ0aWVzID0ge1xuICByZWFkT25seTogW1xuICAgICdoZWFkZXJzJyxcbiAgICAnb2snLFxuICAgICdyZWRpcmVjdGVkJyxcbiAgICAnc3RhdHVzJyxcbiAgICAnc3RhdHVzVGV4dCcsXG4gICAgJ3R5cGUnLFxuICAgICd1cmwnLFxuICAgICdib2R5VXNlZCdcbiAgXSxcbiAgd3JpdGFibGU6IFsndXNlRmluYWxVUkwnXSxcbiAgY2FsbGFibGU6IFtcbiAgICAnY2xvbmUnLFxuICAgICdlcnJvcicsXG4gICAgJ3JlZGlyZWN0JyxcbiAgICAnYXJyYXlCdWZmZXInLFxuICAgICdibG9iJyxcbiAgICAnZm9ybURhdGEnLFxuICAgICdqc29uJyxcbiAgICAndGV4dCdcbiAgXVxufTtcblxuZnVuY3Rpb24gY3JlYXRlRnJpc2JlZVJlc3BvbnNlKG9yaWdSZXNwKSB7XG4gIGNvbnN0IHJlc3AgPSB7XG4gICAgb3JpZ2luYWxSZXNwb25zZTogb3JpZ1Jlc3BcbiAgfTtcblxuICByZXNwUHJvcGVydGllcy5yZWFkT25seS5mb3JFYWNoKHByb3AgPT5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzcCwgcHJvcCwge1xuICAgICAgdmFsdWU6IG9yaWdSZXNwW3Byb3BdXG4gICAgfSlcbiAgKTtcblxuICByZXNwUHJvcGVydGllcy53cml0YWJsZS5mb3JFYWNoKHByb3AgPT5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzcCwgcHJvcCwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gb3JpZ1Jlc3BbcHJvcF07XG4gICAgICB9LFxuICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIG9yaWdSZXNwW3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSlcbiAgKTtcblxuICBsZXQgY2FsbGFibGUgPSBudWxsO1xuICByZXNwUHJvcGVydGllcy5jYWxsYWJsZS5mb3JFYWNoKHByb3AgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNwLCBwcm9wLCB7XG4gICAgICB2YWx1ZTogKChjYWxsYWJsZSA9IG9yaWdSZXNwW3Byb3BdKSxcbiAgICAgIHR5cGVvZiBjYWxsYWJsZSA9PT0gJ2Z1bmN0aW9uJyAmJiBjYWxsYWJsZS5iaW5kKG9yaWdSZXNwKSlcbiAgICB9KTtcbiAgfSk7XG5cbiAgY29uc3QgaGVhZGVyc09iaiA9IHt9O1xuICBvcmlnUmVzcC5oZWFkZXJzLmZvckVhY2gocGFpciA9PiB7XG4gICAgaGVhZGVyc09ialtwYWlyWzBdXSA9IHBhaXJbMV07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNwLCAnaGVhZGVyc09iaicsIHtcbiAgICB2YWx1ZTogaGVhZGVyc09ialxuICB9KTtcblxuICByZXR1cm4gcmVzcDtcbn1cblxuY2xhc3MgRnJpc2JlZSB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3BhcnNlRXJyJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTpcbiAgICAgICAgb3B0cy5wYXJzZUVyciB8fFxuICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgYEludmFsaWQgSlNPTiByZWNlaXZlZCR7b3B0cy5iYXNlVVJJID8gYCBmcm9tICR7b3B0cy5iYXNlVVJJfWAgOiAnJ31gXG4gICAgICAgIClcbiAgICB9KTtcblxuICAgIHRoaXMuaGVhZGVycyA9IHtcbiAgICAgIC4uLm9wdHMuaGVhZGVyc1xuICAgIH07XG5cbiAgICB0aGlzLmFycmF5Rm9ybWF0ID0gb3B0cy5hcnJheUZvcm1hdCB8fCAnaW5kaWNlcyc7XG5cbiAgICB0aGlzLnJhdyA9IG9wdHMucmF3ID09PSB0cnVlO1xuXG4gICAgaWYgKG9wdHMuYXV0aCkgdGhpcy5hdXRoKG9wdHMuYXV0aCk7XG5cbiAgICBtZXRob2RzLmZvckVhY2gobWV0aG9kID0+IHtcbiAgICAgIHRoaXNbbWV0aG9kXSA9IHRoaXMuX3NldHVwKG1ldGhvZCk7XG4gICAgfSk7XG5cbiAgICAvLyBpbnRlcmNlcHRvciBzaG91bGQgYmUgaW5pdGlhbGl6ZWQgYWZ0ZXIgbWV0aG9kcyBzZXR1cFxuICAgIHRoaXMuaW50ZXJjZXB0b3IgPSBuZXcgSW50ZXJjZXB0b3IodGhpcywgbWV0aG9kcyk7XG4gIH1cblxuICBfc2V0dXAobWV0aG9kKSB7XG4gICAgcmV0dXJuIChwYXRoID0gJy8nLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIC8vIHBhdGggbXVzdCBiZSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2BwYXRoYCBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cbiAgICAgIC8vIG90aGVyd2lzZSBjaGVjayBpZiBpdHMgYW4gb2JqZWN0XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucykpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2BvcHRpb25zYCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuXG4gICAgICBjb25zdCB7IHJhdywgLi4ubm9SYXcgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIC4uLm5vUmF3LFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4udGhpcy5oZWFkZXJzLFxuICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVyc1xuICAgICAgICB9LFxuICAgICAgICBtZXRob2Q6IG1ldGhvZCA9PT0gJ2RlbCcgPyAnREVMRVRFJyA6IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgICB9O1xuXG4gICAgICAvLyByZW1vdmUgYW55IG5pbCBvciBibGFuayBoZWFkZXJzXG4gICAgICAvLyAoZS5nLiB0byBhdXRvbWF0aWNhbGx5IHNldCBDb250ZW50LVR5cGUgd2l0aCBgRm9ybURhdGFgIGJvdW5kYXJ5KVxuICAgICAgT2JqZWN0LmtleXMob3B0cy5oZWFkZXJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0eXBlb2Ygb3B0cy5oZWFkZXJzW2tleV0gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgb3B0cy5oZWFkZXJzW2tleV0gPT09IG51bGwgfHxcbiAgICAgICAgICBvcHRzLmhlYWRlcnNba2V5XSA9PT0gJydcbiAgICAgICAgKVxuICAgICAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnNba2V5XTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjID0gY2FzZWxlc3Mob3B0cy5oZWFkZXJzKTtcblxuICAgICAgLy8gaW4gb3JkZXIgdG8gc3VwcG9ydCBBbmRyb2lkIFBPU1QgcmVxdWVzdHNcbiAgICAgIC8vIHdlIG11c3QgYWxsb3cgYW4gZW1wdHkgYm9keSB0byBiZSBzZW50XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL2lzc3Vlcy80ODkwXG4gICAgICBpZiAodHlwZW9mIG9wdHMuYm9keSA9PT0gJ3VuZGVmaW5lZCcgJiYgb3B0cy5tZXRob2QgPT09ICdQT1NUJykge1xuICAgICAgICBvcHRzLmJvZHkgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMuYm9keSA9PT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvcHRzLmJvZHkpKSB7XG4gICAgICAgIGlmIChvcHRzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgb3B0cy5tZXRob2QgPT09ICdERUxFVEUnKSB7XG4gICAgICAgICAgY29uc3QgeyBhcnJheUZvcm1hdCB9ID0gdGhpcztcbiAgICAgICAgICBwYXRoICs9IGA/JHtxcy5zdHJpbmdpZnkob3B0cy5ib2R5LCB7IGFycmF5Rm9ybWF0IH0pfWA7XG4gICAgICAgICAgZGVsZXRlIG9wdHMuYm9keTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBjLmdldCgnQ29udGVudC1UeXBlJykgJiZcbiAgICAgICAgICBjLmdldCgnQ29udGVudC1UeXBlJykuc3BsaXQoJzsnKVswXSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgICkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvcHRzLmJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRzLmJvZHkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGZ1bGxVcmkgPSB0aGlzLm9wdHMuYmFzZVVSSVxuICAgICAgICAgICAgPyB1cmxKb2luKHRoaXMub3B0cy5iYXNlVVJJLCBwYXRoKVxuICAgICAgICAgICAgOiBwYXRoO1xuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsUmVzID0gYXdhaXQgZmV0Y2goZnVsbFVyaSwgb3B0cyk7XG4gICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlRnJpc2JlZVJlc3BvbnNlKG9yaWdpbmFsUmVzKTtcbiAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlcy5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJyk7XG5cbiAgICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgcmVzLmVyciA9IG5ldyBFcnJvcihyZXMuc3RhdHVzVGV4dCk7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSByZXNwb25zZSB3YXMgSlNPTiwgYW5kIGlmIHNvLCBiZXR0ZXIgdGhlIGVycm9yXG4gICAgICAgICAgICBpZiAoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gcGFyc2UganNvbiBib2R5IHRvIHVzZSBhcyBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXMuanNvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgcmVzLmJvZHkgPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXMuYm9keSA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICAgICAgICAgICAgICByZXMuYm9keSA9IEpTT04ucGFyc2UocmVzLmJvZHkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gdXNlIGJldHRlciBhbmQgaHVtYW4tZnJpZW5kbHkgZXJyb3IgbWVzc2FnZXNcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICB0eXBlb2YgcmVzLmJvZHkgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICB0eXBlb2YgcmVzLmJvZHkubWVzc2FnZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHJlcy5lcnIgPSBuZXcgRXJyb3IocmVzLmJvZHkubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICFBcnJheS5pc0FycmF5KHJlcy5ib2R5KSAmJlxuICAgICAgICAgICAgICAgICAgLy8gYXR0ZW1wdCB0byB1dGlsaXplIFN0cmlwZS1pbnNwaXJlZCBlcnJvciBtZXNzYWdlc1xuICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlcy5ib2R5LmVycm9yID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgaWYgKHJlcy5ib2R5LmVycm9yLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgIHJlcy5lcnIgPSBuZXcgRXJyb3IocmVzLmJvZHkuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzLmJvZHkuZXJyb3Iuc3RhY2spXG4gICAgICAgICAgICAgICAgICAgIHJlcy5lcnIuc3RhY2sgPSByZXMuYm9keS5lcnJvci5zdGFjaztcbiAgICAgICAgICAgICAgICAgIGlmIChyZXMuYm9keS5lcnJvci5jb2RlKSByZXMuZXJyLmNvZGUgPSByZXMuYm9keS5lcnJvci5jb2RlO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlcy5ib2R5LmVycm9yLnBhcmFtKVxuICAgICAgICAgICAgICAgICAgICByZXMuZXJyLnBhcmFtID0gcmVzLmJvZHkuZXJyb3IucGFyYW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVzLmVyciA9IHRoaXMucGFyc2VFcnI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiB3ZSBqdXN0IHdhbnQgYSByYXcgcmVzcG9uc2UgdGhlbiByZXR1cm4gZWFybHlcbiAgICAgICAgICBpZiAocmF3ID09PSB0cnVlIHx8ICh0aGlzLnJhdyAmJiByYXcgIT09IGZhbHNlKSlcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlcy5vcmlnaW5hbFJlc3BvbnNlKTtcblxuICAgICAgICAgIC8vIGRldGVybWluZSB3aGV0aGVyIHdlJ3JlIHJldHVybmluZyB0ZXh0IG9yIGpzb24gZm9yIGJvZHlcbiAgICAgICAgICBpZiAoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXMuanNvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJlcy5ib2R5ID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMuYm9keSA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICAgICAgICAgICAgcmVzLmJvZHkgPSBKU09OLnBhcnNlKHJlcy5ib2R5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nKSB7XG4gICAgICAgICAgICAgICAgcmVzLmVyciA9IHRoaXMucGFyc2VFcnI7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMuYm9keSA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIGF1dGgoY3JlZHMpIHtcbiAgICBpZiAodHlwZW9mIGNyZWRzID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgaW5kZXggPSBjcmVkcy5pbmRleE9mKCc6Jyk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKVxuICAgICAgICBjcmVkcyA9IFtjcmVkcy5zdWJzdHIoMCwgaW5kZXgpLCBjcmVkcy5zdWJzdHIoaW5kZXggKyAxKV07XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNyZWRzKSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgY3JlZHMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChjcmVkcy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgY3JlZHMgPSBbJycsICcnXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGNyZWRzLnB1c2goJycpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1dGggb3B0aW9uIGNhbiBvbmx5IGhhdmUgdHdvIGtleXMgYFt1c2VyLCBwYXNzXWAnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNyZWRzWzBdICE9PSAnc3RyaW5nJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F1dGggb3B0aW9uIGB1c2VyYCBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cbiAgICBpZiAodHlwZW9mIGNyZWRzWzFdICE9PSAnc3RyaW5nJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F1dGggb3B0aW9uIGBwYXNzYCBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cbiAgICBpZiAoIWNyZWRzWzBdICYmICFjcmVkc1sxXSkge1xuICAgICAgZGVsZXRlIHRoaXMuaGVhZGVycy5BdXRob3JpemF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGBCYXNpYyAke0J1ZmZlci5mcm9tKFxuICAgICAgICBjcmVkcy5qb2luKCc6JylcbiAgICAgICkudG9TdHJpbmcoJ2Jhc2U2NCcpfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBqd3QodG9rZW4pIHtcbiAgICBpZiAodG9rZW4gPT09IG51bGwpIGRlbGV0ZSB0aGlzLmhlYWRlcnMuQXV0aG9yaXphdGlvbjtcbiAgICBlbHNlIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKVxuICAgICAgdGhpcy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7dG9rZW59YDtcbiAgICBlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoJ2p3dCB0b2tlbiBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZyaXNiZWU7XG4iXX0=